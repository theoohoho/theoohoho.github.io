<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Articles on</title><link>https://theoohoho.github.io/blog/</link><description>Recent content in Articles on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 06 Oct 2020 08:49:55 +0000</lastBuildDate><atom:link href="https://theoohoho.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>挑戰 5 天學會 Golang</title><link>https://theoohoho.github.io/blog/%E6%8C%91%E6%88%B0-5-%E5%A4%A9%E5%AD%B8%E6%9C%83-golang/</link><pubDate>Sun, 09 Apr 2023 15:21:13 +0000</pubDate><guid>https://theoohoho.github.io/blog/%E6%8C%91%E6%88%B0-5-%E5%A4%A9%E5%AD%B8%E6%9C%83-golang/</guid><description>自從 ChatGPT 發布以來，我個人就時常透過 GPT 來協助處理日常自動化工作，尤其是幫公司查內部資料、產生報表，或是 shell command 忘了也可以快速提供我需要的指令組合，省下很多冗余時間，真的舒服~
最近就在想，如果 ChatGPT 可以協助工作、面試、寫履歷，不如也來試試能不能在短時間內熟悉一套程式語言，當然也想寫幾篇文章來紀錄 ChatGPT 安排的學習計畫，究竟成效如何
預計做法會是先讓 ChatGPT 產生一個學習計畫的 template，再根據 template 描述的內容，找出相關資料，擬定一份完整的學習計畫。
正文開始 # 首先，先讓 ChatGPT 扮演角色，請他設計一套學習計畫可以幫助工程師快速學習一套程式語言，期盼他能夠根據學生目標、時間和資源偏好設計學習計畫，並且計畫內容可以列出時間線以及資源連結。
接著便是提出需求，希望 5 天內學習 Golang 並且熟悉重要概念，目標對象是設定以有 3-4 年工作經驗的工程師為準，大概是 intermediate level，資源盡量以文章為主
問題設計的部分，我是參考這位 youtuber 的 question framework: https://www.youtube.com/watch?v=VznoKyh6AXs&amp;amp;t=161s
產出的內容如下圖，可以看到 GPT Bot 有列出每日目標、閱讀資料，和一些 todo action，甚至實作部分也有提供參考連結，而且大部分都是官方資源
老實說一開始還誤會以為一天要看完這些 resource，差點向 GPT 老哥求饒，比如第一天要看完 Golang 的 language spec….
仔細看會發現，其實 ChatGPT 提供的學習方式是有規律的，我的理解是按照 Daily target 決定學習範圍，再搭配資源進行學習，舉例來說:
Day 1 目標是 Get Familiar with Go Syntax，便可以搭配 Go Tour 類似 playground 的介面動手玩玩，以及閱讀 Go language spec 和 Effective Go 了解 Syntax 細節</description></item><item><title>FastAPI 常見問題 - SQLalchemy session</title><link>https://theoohoho.github.io/blog/fastapi-%E5%B8%B8%E8%A6%8B%E5%95%8F%E9%A1%8C-sqlalchemy-session/</link><pubDate>Wed, 08 Mar 2023 15:48:04 +0000</pubDate><guid>https://theoohoho.github.io/blog/fastapi-%E5%B8%B8%E8%A6%8B%E5%95%8F%E9%A1%8C-sqlalchemy-session/</guid><description>最近在壓測系統時，有觀察到 database connection 異常暴漲的問題，原本用 singleton pattern 封裝 database class 解決問題，確保單台 application server 只會有單個 db instance，限制 db connection 不超過 connection pool 的上限，但後續遇到這個錯誤:
調查之後發現，是 FastAPI 專案使用到 sqlalchemy scoped_session 的方式，封裝 session factory，導致錯誤產生。
所以本文將會簡單說明 FastAPI and sqlalchemy 整合的常見問題，會再帶一點 sqlalchemy scoped_session 的介紹
期許讀完這篇文之後，可以了解彼此方法的差異
正文開始 # 一般而言，使用 FastAPI 宣告 database session 的方式有兩種
official: 官方建議，透過 FastAPI 支援的 dependency injection 方式，定義產生 session 的 generator，並 depends 給所有 path operation (aka api endpoint) 使用 middleware: 在 middleware 定義 session create and session close，session 會跟著 request 傳入 path operation (aka api endpoint) 使用 這兩種方式的想要達成的效果相同，都是想讓 db session 的使用週期可以綁定 request 一起開始和結束，簡單來說就是 request 近來會先建立 db session，當 server 產生 response 之後，可以結束 db session</description></item></channel></rss>