{"pages":[],"posts":[{"title":"【快速上車 FastAPI，感受開發快感】 - FastAPI 介紹","text":"FastAPI introductionPython 除了 Flask、Django REST framework 之外，目前又多了一個新的 WEB開發框架可以選擇 - FastAPI FastAPI 主打開發快速、效能快速的 WEB 開發框架，目前星星也在快速成長當中 因為之前專案以 FastAPI 進行開發，所以打算把之前對 FastAPI的理解，寫成一個系列文章 不過本人還很菜，所以決定這次系列主題，會以剛學會程式語言的新手或是 Junior工程師為主要對象 每個章節都會針對技術名詞，做簡單介紹和引用參考，並且會集中說明 FastAPI 的使用術語，一步步無痛引導讀者感受 FastAPI 的好處 現在就開始進入系列主題，【快速上車 FastAPI，感受開發快感】 Outline FastAPI 是什麼? FastAPI 特色 FastAPI 的優點、缺點 What is FastAPI FastAPI framework, high performance, easy to learn, fast to code, ready for production FastAPI 是一個容易上手，並且可以快速開發高效能 WEB API 的框架 從字面上來看 high performance: FastAPI 基於 ASGI framework 建構，可以建立 Async I/O 服務，提供更快速的效能 easy to learn: FastAPI 在初始設計時，便是以容易上手為其中一個目的，除了官方文件寫得清楚之外，模組使用及程式碼描述也具有 intuitive直覺性 fast to code: FastAPI 沒有太多框架提供的特殊語法，大多使用 Python 內建語法及模組，減少額外學習成本；另一方面，FastAPI 在模組使用及程式碼描述上也很 intuitive直覺，開發者可以很快速熟悉框架 另外，FastAPI 完全基於 Python 3.6 版本開發，可以使用許多 Python 3.6 新加入的功能: f-string、type hint ASGI 是什麼? ASGI (Asynchronous Server Gateway Interface) is a spiritual successor to WSGI, intended to provide a standard interface between async-capable Python web servers, frameworks, and applications. ASGI 全名為 Asynchronous Server Gateway Interface，just a little difference with WSGI (Web Server Gateway Interface)，可以在具有 async 功能的 Python web servers、frameworks、applications 之間提供 standard interface FastAPI 特色FastAPI 的作者研究許多知名的開源專案，獲取各個開源工具的優點及設計哲學，經過徹底研究之後，才開發出 FastAPI 框架 以下是 FastAPI 主要特色: FastAPI 完全基於 Python 3.6 版本開發，只支援 Python 3.6 以上的版本 FastAPI 整個框架遵循 Open standard 設計，可以自動產生 Open API 規格的 API 文件 e.g Swagger FastAPI 基於 Starlette 建構，負責處理 Web gateway interface，包括 API path、 FastAPI 基於 Pydantic 建購，負責處理資料輸入/輸出的型別驗證及轉換，可以應用在專案環境變數管理 Open Standard? Open API 是指 Open StandardSwagger 實際上是基於 Open API規格所設計的工具，可以產生 API文件 Starlette 是什麼? 可以做甚麼? 好處在哪? Starlette 是一個 lightweight ASGI framework/toolkit 適合建立 high performance asyncio service，需要搭配 ASGI server 使用 e.g uvicorn 詳細可以參考 Starlette uvicorn 是什麼? uvicorn 是一個使用 uvloop and httptools 實現 ASGI 的 Http Server 詳細可以參考 uvicorn Pydantic 是什麼? Pydantic 是一個使用 python type annotations 來進行資料驗證和設定的管理工具，可以強制在 runtime 執行 type hint，並針對無效的資料提供 user friendly 的錯誤訊息 詳細可以參考 Pydantic 還有一些在開發時，覺得很好用的特點 Editor 支援提供 auto-complete的功能 以上就是 FastAPI 的介紹和特色，之前使用的經驗是，對於需要快速開發 API 服務，並且 API 服務啟動後可以直接提供 Swagger API 文件這一點，有非常驚豔的感受。因為作為開發者，不用再另外處理 Open API 套件鑲入來提供 API 文件，而且一般開發時所描述的資料型別及 docstring，可以直接呈現在 API 文件上的資訊描述，等於是開發者本身在規範程式碼，清楚描述程式碼的同時，便可以直接透過自動生成的 API 文件來反映開發者對於文件描述的程度 Reference FastAPI","link":"/2021/01/09/fastapi-ch0/"},{"title":"【快速上車 FastAPI，感受開發快感】 - 快速感受 FastAPI","text":"Purpose: 快速上手和了解 FastAPI，所以會盡量講解常用到的 API 設定，會避免一些比較深入的設定 此章節主要會從環境安裝開始，簡單走一遍 FastAPI 啟動服務的流程 Outline 環境要求 FastAPI 需要的工具 環境 Setup 建立 Fast instance Execute fastapi web application server 環境要求Python 3.7 FastAPI 需要的工具 Pydantic Uvicorn 環境 Setup 開始之前，也可以先建立虛擬環境進行開發，可以參考 virtualenv 安裝 fastapi 和 uvicorn 12$ pip install fastapi$ pip install uvicorn 如果懶得個別安裝，也可以直接安裝完整工具包 1$ pip3 install fastapi[all] uvicorn 是什麼? uvicorn 是一個使用 uvloop and httptools 實現 ASGI 的 HTTP Server，而 FastAPI 基於 Startlette 框架建構，以及 Starlette 框架屬於實現 ASGI 的框架，如果需要執行 ASGI Web Application，就得需要有支援 ASGI 的 HTTP Server 詳細可以參考 uvicorn 建立 FastAPI instance 在指定目錄內建立一個 main.py 檔案 1$ mkdir fastapi_pratice 編輯 main.py，並建立 FastAPI instance 12345# import FastAPI modulefrom fastapi import FastAPI# 建立 FastAPI instanceapp = FastAPI() 定義一個 GET method 的 api endpoint 及命名 api path 123@app.get('/')def foo(): return 'Hi this is a test.' 解析上述程式碼: @app 是一個 path operation decorator，可以指定要執行哪一種 path operation GET: @app.get POST: @app.post PUT: @app.put PATCH: @app.patch DELETE: @app.delete foo() 執行函式，主要描述需要實現的邏輯。在 FastAPI 會把這類函式統稱為 path operation function 所以整段程式碼是在表達，在 foo() 上面套用 @app，主要是告訴 FastAPI foo() 會對應路徑為 '/' api path，當 FastAPI Application Server 收到 HTTP request 的路徑為為 /時會呼叫 foo() path operation 是什麼? 可以視為 HTTP method decorator 是什麼? 裝飾器，是 python 提供的語法，可以把 function 獨立套用到任一 function，以實現裝飾器設計模式的效果 Execute fastapi web application server當 WEB Application 執行檔完成之後，便能執行 1$ uvicorn main:app --reload 解析上述指令: main 為指定 fastapi 進入點的執行檔案 e.g main.py app 為指定該執行檔案內，所宣告為 FastAPI instance 的變數，從上述來看我們命名 app variable 為 FastAPI instance --reload 為指定 uvicorn 每次只要 fastapi 程式碼有任何更動，都需要重新啟動 Server已同步更新更正內容，通常只在進行開發時使用 For example: 我將 fastapi 進入點檔案命名為 app.py，並且在檔案內建立一個 FastAPI instance，並 assign 給命名為 app 的變數，所以當我需要啟動 server 時，就需要輸入 $ uvicorn app:app 此時前往 http://127.0.0.1:8000/docs 便能看到所產生的 Open API 文件(Swagger)，而 API 文件本身可以進行互動操作，所以未來開發的任何一支 API 如果想要進行手動測試，便可以直接在上面操作 現在應該大概了解 FastAPI 的使用流程，下一個章節則會介紹如果要實現一個讀取資料的 RESTful API，該知道哪些設定以及定義呢? Reference此篇內容參考以下: FastAPI Official - First Step","link":"/2021/01/09/fastapi-ch1/"},{"title":"【快速上車 FastAPI，感受開發快感】 - 定義 Path parameter 和 Query Parameter","text":"從上一章已經大致了解，FastAPI 如何建立 fastAPI instance，以及定義一個簡單的 api router 之後，啟動 uvicorn server 來使用 FastAPI 所產生的 OpenAPI 文件，並進行 API 操作 接下來這一章節的目的，會介紹如何設計一個讀取資料的 API，以及該進行哪些設定及定義 Outline前面兩個章節會簡單介紹 API 和 REST 概念， 後面兩個章節會介紹 Query parameter 和 Path parameter，最後是設計一支 HTTP GET method 的 Restful API API 是什麼? RESTful 是什麼? 定義 query parameter 定義 path parameter 甚麼是 API? API 全名為 Application Program Interface，主要定義應用程式的資料輸入輸出介面，使用者可以透過呼叫 API，來取得 API提供者所提供的資料，又或是透過 API 發送資料給 Server 如果之前去過線上購物商城買東西，回憶一下，大多畫面首先呈現的是一長串的商品列表，當找到有興趣的商品之後，會點進去商品資訊頁面，去看商品的詳細資訊 這些我們平時熟悉的網站，在背後進行資料傳輸的通訊介面，就是 API，這些 API 在上述這個場景的目的是提供資料給使用者去讀取 甚麼是 Restful?Restful 是一個 API 設計風格 關於 Restful 的參考資料，可以從 google 上找到許多資料，這邊就不特別引用參考 定義 path parameter根據 Restful 的設計風格，在設計一隻 GET method API時，如果是要讀取單一資源，可以透過提供 URI 並帶入 path parameter 的方式，來索取特定資源 如果是要讀取所有資源，並且希望能夠進行排序、筆數限制等操作，則可以透過帶入 query parameter Path parameter 是什麼? 可以作為 URL一部分的變數，通常會應用在指定路徑的 URI Query parameter 是什麼? 通常會放在 URL 最後面，並且以 ?區隔開來 假設現在有個情境，要做一間書店，書店需要提供很多書籍資料，也需要提供一本書的詳細資訊，所以起碼要有兩隻 API 來提供這兩個功能，如下 提供所有書籍資料: GET books/ 提供一本書籍資料: GET books/{book_id} 1234567from fastapi import FastAPIapp = FastAPI()book_storage = ['加碼特斯拉','一泊二日好去處','鳳梨圖鑑']@app.get('/books/{book_id}')def get_book(book_id: int): return book_storage[book_id] 解析程式碼 @app.get: 定義一個 path operation decorator，並指定 GET operation @app.get('/books/{book_id}'): 在定義好 path operation，命名使用的 path 為 /books/，後面加入 path parameter {book_id} def get_book(book_id: int):: 定義 get_book path operation function，並指定 book_id argument 描述整段程式碼當我們定義好 path operation decorator 並在命名路徑中加入以大括號包住的 path parameter {book_id}，當這隻 API 收到 HTTP request 時，會對應 book_id path parameter的位置抓取 value，並自動傳入到 get_book path operation function 的 book_id argument 所以如果請求呼叫 GET /books/1 API的話，則呈現結果會是 '一泊二日好去處' Data conversion &amp; validation另外，FastAPI 有支援 data conversion 的功能，可以注意到 get_book(book_id: int) 是把 book_id 指定為 int，所以 HTTP request 打到這隻 API時，會自動轉化 path parameter 的資料型別從 str 轉化為 int (因為 HTTP request path的資料型別為 str) 不過需要注意的是如果 parameter 所保有的 value，如果不符合轉化後的型別，一樣會發生錯誤，比如 HTTP request books/abc 除了 data conversion，FastAPI 也支援 data validation，如果測試 API 是透過 OpenAPI 文件操作，則實際上收到的錯誤訊息，會明顯提示說是 data type 的問題 FastAPI 主要透過 Pydantic 來實現 Data conversion 和 Data validation，詳請可以參考 chapter 1 注意宣告 API 的順序在使用 WEB API 框架開發時，偶而有種情況是如果我想要多定義一隻固定 API，讓我獲取固定資料就行 e.g 定義一隻 API，預期回傳只有我會看的書 /books/only_for_me，如下 1234567891011\"\"\"錯誤範例\"\"\"@app.get('/books/{book_id}')def get_book(book_id: string): print(f'Return book to Client: {book_id}') return book_id@app.get('/books/only_for_me')def get_book_only_for_me(book_id: string): return 'the book that I can read only' 當執行上述錯誤範例程式碼，並進行操作測試時，會發現怎麼發送請求給 /books/only_for_me都不是預期的結果，但是發送請求給 /booKs/1 就沒問題 這是一個很典型的 API route 宣告順序問題，可以思考一下，API route 是不是一樣的 HTTP Method、一樣的 path prefix、一樣的 path parameter 位置 原因在於，當兩個定義的 API route有衝突時，因為 FastAPI 是按照 API 宣告順序來決定執行哪一個 path operation的關係，所以會優先以前面宣告的 API 為主要呼叫對象 (如上，request 是跑到 get_book() 而不是 get_book_only_for_me()) 所以針對上述狀況，可以試著調整 API 宣告順序 12345678\"\"\"以下是針對這類特殊情況所建議的宣告順序\"\"\"@app.get('/books/test')def get_book(book_id: string):@app.get('/books/{book_id}')def get_book(book_id: string): 定義 query parameter當已經清楚 path parameter 如何定義之後，接下來需要知道如何定義 query parameter Query parameter 以 ? 和 URL 區隔，並以 key-value pair 進行參數指定和待入資料，如果有多個 query parameter 則以 &amp; 區隔 e.g., /books?name=jack&amp;age=456 以下為範例程式碼 12345678910111213141516171819book_storage = ['加碼特斯拉','一泊二日好去處','鳳梨圖鑑']@app.get('/books/{book_id}')def get_book(book_id: int): return book_storage[book_id]@app.get('/books')def get_all_books(limit: int = 3, sort_by: str = 'asc', show_metadata: bool = False): respond_books = { 'data': [] } if sort_by == 'desc': book_storage.reverse() respond_books['data'] = book_storage[:limit] if show_metadata: respond_books['count'] = limit return respond_books 描述整段程式碼:當我們定義好 path operation，只要 path operation function 定義的 argument 沒有作為 path parameter ，出現在 path operation -decorator 的命名路徑中的話，則 FastAPI 會自動把 argument 視為 query parameter 所以從上述程式碼來看，已經定義好了三個 query parameter limit: 限制資料筆數，預設值為 3 sort_by: 決定倒序資料，還是正序資料，預設值為 asc show_metadata: 支援額外資料格式，預設為 false 如果請求呼叫 GET /books?limit=2，則呈現結果會是 { 'data': ['加碼特斯拉','一泊二日好去處'] } Data conversion and Data validationQuery parameter 同樣也有支援 Data conversion and Data validation 特別是上述程式碼中出現的 show_metadata，在 FastAPI 中，只要 query parameter 註解型別為 bool，則 FastAPI 會以下面幾個數值進行判斷 True: yes, true, 1, on e.g /books?limit=2&amp;show_metadata=yes False: no, false, 0, off e.g /books?limit=2&amp;show_metadata=off Query parameter and Path parameter另外 Query parameter 和 Path parameter 可以一起定義在 path operation，只要 path operation function 的 argument 有定義在 api path，則 FastAPI 都會自動視為 Path parameter，其他則視為 Query parameter For example123456789@app.get('/books/{book_id}')def get_book(book_id: int, show_price: bool = False): res_book = { \"id\": book_id, \"name\": \"蘋果日報\", } if show_price: res_book['price'] = 100 return res_book Reference Path Params Query Params 理解到這個階段之後，相信讀者們應該知道如何在 FastAPI 宣告一個讀取資料的 API，並且可以根據 API 目的，定義 API 的 path/query parameter 下一個章節，將會介紹如何實現一隻以新增資料為目的的 API 最後，針對 Path parameter 和 Query parameter，FastAPI 還提供了一些進階設定，其中包括可以規範這兩個 parameter 的長度限制、別名、加入 regex…，如果有興趣的讀者可以繼續往 進階用法章節了解 進階用法待補充 - predefined path parameter 待補充 - query parameter and string validation 如果需要針對 path parameter or query parameter 增加 metadata or type validation 的話，FAST API支援 import 各自的 module來實現metatdata 比如有: title type validation 比如有: ge=1greater than or equal 1 le=3less then 3 gt=5 greater than 5 lt=5.5 less than 5.5 12345678from fastapi import Path, Query@app.get('/users')def get_user(order_by: str = Query(..., title=\"this is order_by attribute\"))# 比較特別的是 path parameter，即便有使用 module，並且給予 default value，FAST API 在接收 request 時，還是會要求需要帶數值，才能運作@app.get('/users/{user_id}')def get_user(user_id: str = Path(..., title=\"this is a user id\"))","link":"/2021/01/10/fastapi-ch2/"},{"title":"【快速上車 FastAPI，感受開發快感】- 定義 Request Body 和 Pydantic model","text":"從上一個章節【定義 Path parameter 和 Query Parameter】已經大致了解，FastAPI 如何實現一個讀取資料的 API，以及定義 API 需要的 Path parameter 和 Query Parameter 接下來這一章節的目的，則會介紹如何實現以新增資料為目的的 API，以及可以進行的設定 Outline Request body 是什麼? Pydantic 定義資料格式 預先定義 request body 定義新增資料的 API 實作新增資料邏輯 啟動 HTTP Server Reference 進階用法 function argument 混和宣告不同的 parameter Body module 設定 Request body 是什麼?大致上來說 HTTP API，都只是定義一個 Request可以怎麼發送資料給 HTTP Server，不管是 HTTP GET、POST、PUT、PATCH、DELETE method 都是一樣的行為 只是 HTTP 有規範不同 HTTP Method 有不同的使用目的，在使用目的不同的前提下，某些對應 HTTP method的 request 不應該加入特定的參數，因為這樣違反規範 e.g GET Method 的 request 就被規範不應該加入 request body/payload GET v.s POST 很常見的面試題目，測試面試者對於 HTTP 的熟悉度 兩者可以發送資料給 HTTP Server，主要差異在於，POST method 可以將資料放在 request body，而 GET method 在 HTTP 的規範中表示加入 request body，則沒有支援 request body 所以當使用者需要發送私人資料或是不需要公開的資料時，使用 HTTP POST method 的 request 是比較適當的方式，因為當 Backend 的 WEB Server 有支援 HTTPS protocol時，request body 內的資料可以被加密保護，當 request 發送到網路上，轉換成封包資料飛來飛去的時候，已經是加密過的封包，使用者便不用擔心剛剛傳輸的資料會被人偷窺 而 request body 通常會在 HTTP POST method 的 request中使用，主要就是將資料放到 request body並發送給相對應的 API request body 支援許多資料格式，大部分都是以 JSON 為主要資料格式進行傳輸 而在 FastAPI 中，會使用 Pydantic 來定義 Server 接收到 request之後， request body 所需要攜帶的參數 透過 Pydantic 的特性，來進行資料驗證及型別轉化 Pydantic Pydantic 介紹、支援功能、應用在哪些地方 FastAPI 主要使用 Pydantic 建立 Request body model，當 api server 收到 request之後，會自動轉換為對應的 model Pydantic 的一個特點是，強制在 runtime 時使用 type hint，並且在 data invalid時提供明確清楚的錯誤回報，告訴開發者哪邊出了錯誤 Pydantic 使用 python type annotations 做到 data validation and settings management 今天想要實作一個新增書本資料的 API，整個流程會是 定義書本資料格式 以書本資料格式來定義 request body 可以接收的資料內容 定義新增資料的 API 實作新增資料邏輯 定義資料格式這邊將使用 Pydantic 來定義資料格式 12345678910# 1. Import pydanticfrom pydantic import BaseModel# 2. 建立 data model# 透過宣告 class 並繼承 Pydantic BaseModel，變可以實作一個 data modelclass Book(BaseModel): book_id: str book_name: str book_price: int book_type: str Pydantic model 定義的 attribute 沒有設定 default value，就會是 required，如果不給予 value會回報錯誤 下面是一個以 Pydantic 定義的 JSON object(aka Python dict)，以 Book 為範例 123456{ \"book_id\": '', \"book_name\": '', \"book_price\": 0, \"book_type\": '',} 如果想要某些參數是 optional，也就是不一定要設定參數的話，可以透過 python 內建模組 typing 使用 Optional 或 Union 關於 Optional 和 Union 的差別可以從 official doc 來了解Python3 - typing 123456from typing import Optional, Unionclass Book(BaseModel): book_id: str book_name: str book_price: int book_type: Optional[str] # 預設值為 None 預先定義 request body定義好書本資料的完整格式之後，可以先思考如果使用者要新增一本書，有需要自行設定所有資料並放到 request body嗎? 因為像是 book_id 這類 ID 的資料，應該由系統透過一些 uuid 模組或是加密模組自動產生資料會比較適當 所以針對這類型的資料參數，不希望放進 request body 的情況，Pydantic 的 data model 也可以透過物件繼承 inheritance 的方式來組合不同 data model 另一個好處是，可以減少定義相同的資料參數 拆解前的資料格式 123456# 這是一開始定義的資料格式class Book(BaseModel): book_id: str book_name: str book_price: int book_type: str 透過 Pydantic 的特性，將這些定義好的 data model，以物件繼承的方式，組合深層結構的 data model 12345678910111213class BookBase(BaseModel): \"\"\"通用的書本資料 model\"\"\" book_name: str book_price: int book_type: strclass BookInfo(BookBase): \"\"\"完整的書本資料 model\"\"\" book_id: strclass NewBook(BookBase): \"\"\"提供給新增書本 API的 request body\"\"\" pass 定義新增資料的 API定義好書本資料以及提供新增資料 API可使用在 request body 的 data model之後，便可以開始定義 API 123@app.post('/books')def create_book(new_book: NewBook): pass 解析程式碼 @app.post('/books'): 定義 path operation 為 POST，並命名路徑為 /books，因為 HTTP method 不同，所以 request是可以明確呼叫 GET 或 POST 的，不會受到相同路徑影響 def create_book(new_book: NewBook): 在 chapter 3有提到 path operation function 的 argument 如果沒有出現在 api route 上，會被視為 query parameter，不過 FastAPI 在 path operation function 會判斷如果 argument 為 Pydantic model，則會被自動視為 request body pass: 暫時不實現邏輯，下一個 section 會介紹 針對在 function 內加入多個可以作為 Request body 的 argument，請參考下面的 進階用法-function argument 混和宣告不同的 parameter 如果是針對如何在 path operation 加入單獨一個 request body attribute，請參考下面的 進階用法-Body module 設定 實作新增資料邏輯1234import uuid@app.post('/books')def create_book(new_book: NewBook) -&gt; BookInfo: return BookInfo(**new_book.dict(), book_id=uuid.uuid4()) 解釋程式碼: import uuid: import 內建模組 uuid，自動產生獨立的字串 def create_book(new_book: NewBook) -&gt; BookInfo: 定義 API 輸出的資料格式為 BookInfo，OpenAPI 會自動產生對應的資料模型 new_book.dict(): 是 Pydantic 內建支援的方法，可以將 Pydantic model 轉成 dict type BookInfo(**new_book.dict(), book_id=uuid.uuid4()): 是將轉換成 dict type的 new_book 參數，以 keyword argument 傳送進 BookInfo Pydantic model，並只保留 attribute 相符合的資料，在 FastAPI 中會很常使用這個方法 關於 dict() 資料轉化的說明可以參考 FastAPI - Extra models 啟動 HTTP Server執行 1$ uvicorn main:app Reference FastAPI- Request Body FastAPI - Extra Model 進階用法function argument 混和宣告不同的 parameter Path parameter 和 Request Body 1234# FastAPI 會自動匹配 function parameter 和 path parameter，並從 path parameter 取得 value pass給 function argument@app.put('/user/{user_id}')def update_user(user_id: str, updated_user: UserInfo): return updated_user 針對 query paramter, path parameter, request body 這三種類型的 function parameter，FastAPI 一樣可以自動判斷path parameter 透過與 path 匹配來判斷query parameter 只要 parameter name 沒有定義在 path，以及型別沒有宣告為 Pydantic modelrequest body 只要 parameter 宣告為 Pydantic model 多個宣告為 Request body的 parameter 123@app.post('/book')def create_book(user_info: UserInfo, new_book: Book): return new_book 預期的 request body 如下123456789101112{ \"user_info\": { \"username\": \"\", \"email\": \"\", \"phone\": 0 }, \"book\": { \"name\": \"\", \"type\": \"\", \"price\": 0 }} Body module 設定FAST API 提供 Body module，可以指定 function argument 為 request body 的參數，並設定額外的 metadata or validation 而 Body 的應用場景有兩種: 可以提供 request body 額外 metadata 和 validation 可以宣告額外/單獨的 request body 參數 (通常會在 request body 只有一兩個參數，不想要另外定義 Pydantic model 時使用) 下面是宣告單獨 request body 參數的範例 1234# 原本 user_info 內宣告的參數全部集中在 body attribute user_info，形成巢狀結構，並且在 request body 第一層加上新的 attribute# Body(...) 第一個 argument 為設定預設值，如果不需要設定預設值直接 asigne 三個小數點就行@app.post('/user/set')def set_user(user_info: UserInfo, activate: bool = Body(...)): 預期的 request body 如下12345678{ \"user_info\": { \"username\": \"\", \"email\": \"\", \"phone\": 0 }, \"activate\": False} 注意: 如果沒有帶入 Body module 的話，FastAPI 會把這個參數視為 query parameter 另外如果 API 只需要設定單獨一個 request body attribute 的話，建議可以特別在 Body 內加入 embed=True 這個屬性 否則 FastAPI 在 OpenAPI 上看這隻 API時，會發現 request body 內沒有提供 attribute name，只有呈現數值，給我們填入而已 Body沒有加入embed=True的範例 12@app.post('/test')def test(activate: bool = Body(...)): OpenAPI 上看到的 request body，只能夠填入數值，不是 json 格式1true Body有加入embed=True的範例 12@app.post('/test')def test(activate: bool = Body(..., embed=True)): OpenAPI 上看到的 request body1{\"activate\": true} 不過針對 function 有多個宣告為 Body 的 argument 而言，便不會有這類狀況出現 12@app.post('/test')def test(user_name: str = Body(...), activate: bool = Body(...)): OpenAPI 上看到的 request body1{\"user_name\":'', \"activate\": true} 另外一個會使用到 embed 的情況是，希望單獨宣告 Pydantic model 的 argument，也可以在 request body 內明確指定 function argument name 12@app.post('/test')def test(user_info: UserInfo = Body(..., embed=True)): OpenAPI 上看到的 request body1{\"user_info\": {\"username\": \"\", \"email\": \"\",\"phone\": 0}}","link":"/2021/01/13/fastapi-ch3/"},{"title":"【快速上車 FastAPI，感受開發快感】 - 定義 Response 和 Exception","text":"從上一個章節【定義 Request Body 和 Pydantic model】已經大致了解，FastAPI 如何實現一個以新增資料為目的的 API 接下來這一章節的目的，則會介紹如何在 FastAPI 定義 Response 及 Exception Outline Response Exception Reference 進階用法 ResponseFastAPI 可以設定 response_model 定義 API 輸出的資料格式 以下是 response_model 提供的幾個特點: 驗證 API response 的輸出資料 轉化輸出資料對應 response_model 所定義的資料型別 可以根據 response_model 所定義的資料格式，限制可以輸出的資料 輸出資料格式一樣可以生成 JSON schema，在 OpenAPI 上呈現，方便開發者可以直接從文件上看到 API預期回傳的資料格式 1234567891011121314151617181920from pydantic import BaseModelclass UserBase(BaseModel): username: str class UserIn(UserBase): password: strclass UserInfo(UserBase): email: str phone: int@app.get('', response_model=str)def test(): return 123# 發送 request 到這隻 API，request body 內有包含 username 和 password# 而 path operation function 的邏輯內沒有經過額外處理，便直接將 request body 的資料回應輸出# 最後輸出資料會因為經過 response_model 所定義的資料格式限制，過濾掉 password 這個 attribute@app.post('/user/login', response_model=UserBase)def login(user_in: UserIn): return user_in 可以從 OpenAPI 產生的文件上看到，API 有包含輸出資料的格式，方便開發者了解 API以上大致內容出自 FastAPI - Response Model 定義 response_model 其他資料型別另外 response_model 也可以定義 Optional、Union、List 類型的資料型別 可以參考 FastAPI - Extra Model 定義 HTTP status code除了定義 response_model之外，也可以定義 API 預期回應的 HTTP status code在 path operation 123@app.post('/user/login', response_model=UserBase, status_code=201)def login(user_in: UserIn): return user_in 如果覺得 HTTP status code 記不太起來，但是知道狀態訊息類別，也可以使用 FastAPI 提供的 status 1234from fastapi import FastAPI, status@app.post('/user/login', response_model=UserBase, status_code=status.HTTP_201_CREATED)def login(user_in: UserIn): return user_in 如果需要針對不同 API 處理狀態，提供適當的 http status code的話也可以參考這邊 FastAPI - Change Status code Exception 什麼是有益的 Exception? 在回應錯誤訊息中，訊息內容能不能夠準確描述錯誤原因，以及透過狀態碼讓 Client 更快速了解錯誤類別，便是有益的 Exception FastAPI 提供 HTTPException 來 raise 錯誤 FastAPI 的 HTTPException 有個特點是直接繼承 Python 的 Exception，所以可以用 raise 拋出錯誤 透過使用 raise 的其中一個好處，當我們建立通用方法，提供給 path operation 時，也可以在通用方法邏輯內，直接 raise exception中斷程式繼續執行。 這一個特點，對於在 FastAPI 使用 Dependencies 或是 Security 設定時，會很有幫助。 另一個用 raise 的好處，當然就是寫法很直覺明確 以下是一般使用 HTTPException 範例 123456789101112# 1. 先 imoprt fastapi.HTTPExceptionfrom fastapi import HTTPException# detail 主要放置錯誤回傳訊息，可以接收 str, list, dict 這些類型的資料# 這些資料最後會由 FastAPI 自動轉換為 JSON@app.get('/test')def test(): raise HTTPException( status_code=404, detail='Something not found', headers={'header_field': 'header_value'} ) 當然也可自訂 exception Custome exception 12345678910111213141516171819202122from fastapi import FastAPI, Requestfrom fastapi.responses import JSONResponse# 1. 建立 custom exception，並繼承 Python Exceptionclass LetMeCustomException(Exception): def __init__(sefl, message: str) self.message = message# 2. register exception into FastAPI instance, make FastAPI can globally handle this exception@app.exception_handler(LetMeCustomException)def custom_exception_handler(request, exc: LetMeCustomException): # 3. exception handler can return clear content with JSON format print('Hey! Review this error message', exc) return JSONResponse( status_code=400, content={\"message\": f\"Oops! {exc.message} did something. There goes a rainbow...\"}, )# 4. raise custome exception@app.get('/test')def test(): raise LetMeCustomException(message='I do not know why I got this error') 除此之外，也可以覆蓋 FastAPI 預設的 Exception 比如 reqeust 含有無效的資料，FastAPI 預設是 raise RequestValidationError (這個 Exception 繼承 Pydantic 的 ValidationError 可以拋出明確資料錯誤訊息)，我想去修改這個 exception 的訊息格式，把 JSON 改回 Plain text 12345678from fastapi import Requestfrom fastapi.exceptions import RequestValidationErrorfrom fastapi.responses import PlainTextResponse@app.custom_exception_handler(RequestValidationError)def validation_exception_handler(request, exc): print('Hey! The client request invalid data!', exc) return PlainTextResponse(str(exc), status_code=400) 或者是以覆蓋的方式來調整 FastAPI 預設 HTTPException 的資料格式或行為 這邊比較特別的是，如果想要覆蓋 HTTPException，官方文件建議直接覆蓋 Starlette 的 HTTPException 因為 FastAPI 基於 Starlette 建構框架，許多 WEB request/response 處理都是直接繼承 Starlette 的 module 所以透過直接修改 Starlette Exception，這樣便能夠一起調整 Starlette 內同樣繼承或使用 Starlette HTTPException 的程式碼/extension/plug-ins 12345678from fastapi import Requestfrom fastapi.responses import PlainTextResponsefrom starlette.exceptions import HTTPException as StarletteHTTPException@app.custom_exception_handler(StarletteHTTPException)def http_exception_handler(request, exc): print('Hey I got http error!', exc) return PlainTextResponse(str(exc.detail), status_code=exc.status_code) Reference以上內容均參考至 FastAPI - Response Model FastAPI - Response Status code FastAPI - Handling Errors 進階用法待補充","link":"/2021/01/16/fastapi-ch4/"},{"title":"【快速上車 FastAPI，感受開發快感】 - 資料庫連線及操作","text":"從上一個章節【定義 Response 和 Exception】已經大致了解，FastAPI 如何定義 Response 及 Exception 接下來這一章節的目的，則會介紹如何在 FastAPI 進行 database connection 和 database operation Outline FastAPI and SQLAlchemy 檔案結構 Initial create SQLAlchemy 建立 SQLAlchemy ORM model 建立 Pydantic model 如何進行 Pydantic model 和 ORM model 資料搬移? Pydantic model Config 建立資料庫 CRUD 方法 實際使用 database operation 在 path operation 使用 database operation Reference 進階用法 FastAPI and SQLAlchemyFastAPI 主要使用 SQLAlchemy ORM 來進行 database connection 及操作，所以基本上 database 這部分的處理都是以 SQLAlchemy 標準操作為主 SQLAlchemy ORM 可以支援許多 RDBMS e.g PostgreSQL、MySQL、SQLite、Oracle、MS SQL Server可以參考 SQLAlchemy 甚麼是 ORM? ORM 全名叫做 Object relational mapping，可以將程式語言建立的 object 和 database table 進行 mapping 白話一點就是將物件資料轉化成 database table，所以一個物件資料如果視為 database table的話 比如說: 物件本身代表一個 table，物件內的 attribute 代表 table field/column 有包含名稱及資料型別，物件內的 attribute value 代表 table row 以 class 來解釋的話 一個 class 為一個 table e.g class Car，class 內定義的 attribute 為 table 的 field/column e.g Car.name，以 class 實現的 instance 為 table row e.g car_A = Car() 所以當指定 class.attribute時，ORM 會幫開發者進行 relation mapping 找到對應的 Table 及 column 來取得數值，又或是 class.attribute = value，進行修正 row 資料的操作，ORM 也可以幫我們找到對應的 ROW 進行調整 以上內容均參考自 FastAPI - SQL (Relational) Databases 檔案結構根據 FastAPI 對於 Database 操作的檔案結構建議分成: database.py: 主要定義 database session，處理 database setup 和 connetion models.py: 主要定義定義可以 mapping to database table 的 ORM model，codebase 這邊會以 model 作為 database table，並對 model 進行 table 操作 schemas.py: 主要定義 Pydantic model，可以針對 ORM model 的資料進行資料驗證/轉化，或者過濾資料 crud.py: 主要定義 ORM model 的資料庫操作行為 main.py: 主要程式進入點，定義之前章節所建立的 API Initial create SQLAlchemyReference Database Session 是什麼? In the most general sense, the Session establishes all conversations with the database and represents a “holding zone” for all the objects which you’ve loaded or associated with it during its lifespan. Session 是建立與 database 的所有連線，並且在 session 生命週期中，database session 會作為所有已載入 object或是關聯 object 的一個 holding zone(白話一點就是，session是一個等待區，可以把已載入物件和關聯物件丟進來) 想要了解更多關於 SQLAlchemy 針對 Session 的介紹，以及處理可以參考 Reference SQLAlchemy 初始建立 database session流程: Edit database.py Import sqlalchemy packages Setup DB URL Create an Engine，可以讓 database session 連接資源 Create a Session as Database Session to interact with DB Create Base for later create DB model or ORM model Create a get_db_session function to get database session instance 以兩個 Database configuration 例子來介紹: SQLite1234567891011121314151617181920212223from sqlalchemy import create_enginefrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import sessionmakerDB_URL = \"sqlite:///./sql_app.db\"# 只有 sqlite 需要加上 check_same_thread 的 attribute# 因為 SQLite 每次只可以接收一個 thread 來處理一個 requestEngine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False})# 由於 sessionSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=Engine)# 建立 Base，作為後續建立 ORM model 時需要繼承的對象Base = declarative_base()# 建立 get_db_session() 並實現一個 database session instance and yield itdef get_db_session(): db = SessionLocal() try: yield db except Exception: db.rollback() raise finally: db.close() 特別解釋一下 get_db_session()，這邊使用了 Generator 的語法 第一次呼叫 get_db_session() 會先回傳 generator 第二次使用，會透過 yield 回傳建立好的 session instance 當 session 拋出去的過程中，遇到錯誤，則會執行 rollback() 最後不管 session 成功執行或遇到錯誤，都會 close() 關閉 session 連線 關於 Genertator 語法的介紹，這邊就不再多描述，可以參考Real Python的介紹 PostgreSQL123456789101112131415161718from sqlalchemy import create_enginefrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import sessionmakerDB_URL = \"postgresql:username:password@db_server/db_name\"Engine = create_engine(SQLALCHEMY_DATABASE_URL)SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=Engine)Base = declarative_base()def get_db_session(): db = SessionLocal() try: yield db except Exception: db.rollback() raise finally: db.close() 建立 SQLAlchemy ORM model Edit models.py create class inherit Base from initial create SQLAlchemy create model correspond table name create attritube/columns create relationship Pydantic model v.s ORM model 這兩個 model雖然都是用來描述資料模型，但彼此使用目的不同 Pydantic model 目的在於定義資料格式，實現資料輸入驗證、轉化輸出資料型別 ORM model 則是定義 database 資料模型，建立 Database connection，並且實現資料庫操作 123456789101112131415161718192021222324from sqlalchemy import Boolean, Column, ForeignKey, Integer, Stringfrom .database import Baseclass User(Base): # create __tablename__ attribute，宣告 model 對應的 database table name __tablename__ = \"users\" # create class attribute，宣告 model 對應的 table field/column id = Column(Integer, primary_key=True, index=True) name = Column(String, index=True) email = Column(String, unique=True) active = Column(Boolean, default=True) # create relationship 建立 Table 關聯 books = relationship(\"Books\", back_populates=\"owner\") class Books(Base): __tablename__ = \"books\" id = Column(Integer, primary_key=True, index=True) title = Column(String, index=True) description = Column(String) price = Column(Integer) owner_id = Column(Integer, ForeignKey(\"users.id\")) # create relationship owner = relationship(\"User\", back_populates=\"books\") 解釋一下兩個 ORM model Users (users table)和 Books(books table)如何建立關聯 當兩張 table 建立好關聯之後，假設 database 目前資料狀態是一個 user 有多本書，我們從 database 讀取 user之後抽取一個 Users model (這邊以 my_user表示)，並指定 my_user.books，database 會透過 Foreign key 找到和 Books model 相關聯的資料 row，並回傳和該 user 關聯的所有書本資料 Books model 而如果從 database 抽取一個 Books model(以 my_book 表示)，並指定 my_book.owner便可以取得 更多 SQLAlchemy 定義 ORM model的細節，可以參考SQLAlchemy official doc 建立 Pydantic modelPydnatic model 目的是可以針對 Table 資料，進行資料驗證或轉換 通常大部分應用層面的操作，資料都會盡量以 pydantic model 封裝起來，維持嚴謹資料格式，直到要將資料從 database 讀取或是寫入進 database時，才需要使用 ORM model 所以在定義銜接 orm model 的 pydantic model時，可以先思考哪些情境下會使用到 Pydantic model，以及在該情境下進行資料操作時，有哪些設定可以在 pydantic model 那邊實作，比如: 新增一個 database table row，希望由系統自動產生 table id 或是時間欄位，所以把產生 id or 產生時間資料的程式碼固定在 pydantic model，讓我每次建立新的 pydantic model 時都可以自動幫我產生資料 而 Pydantic model 針對 orm model 定義資料格式有幾種選擇: 可以根據 orm model 照實定義 pydantic model 也可以將自己認為不必要的資料過濾掉 以下程式碼需要寫在 schemas.py 123456789101112131415from pydantic import BaseModel, Fieldfrom typing import Listclass Books(BaseModel): id: int = Field(...) title: str = Field(...) description: str = Field(...) price: int = Field(...) owner_id: int = Field(...)class User(BaseModel): id: int = Field(...) name: str = Field(...) email: str = Field(...) active: bool = Field(...) books: List[Books] 如何進行 Pydantic model 和 ORM model 資料搬移?現在已經知道 Pydantic model 和 ORM model 的目的，以及如何定義兩個 model 接下來，這邊將會簡單呈現，如何透過 orm 執行 database query，並將回傳結果的 orm model搬移到 pydantic model 的過程 關於 ORM 的 DATABASE OPERATION 會在下個章節介紹，這邊的重點會著重在兩個 model的資料搬移 以下是一個簡單的範例，建議可以建立一個測試腳本 e.g test.py 來試試 這邊預期開發者已建立好 database及對應的 table schema如果開發者尚未建立 database 及 table schema，以下程式碼將會無法使用建議開發者們可以自行手動建立 database and table schema 或是使用 database migration如果不清楚 database migration，可以參考 Database migration 1234567891011121314151617181920212223242526# assume create a test.py, and write in# import database session, user orm model, user pydantic modelfrom .database import get_db_sessionfrom .schemas import User as UserSchemafrom .models import User# import fastapi special encoder jsonable_encoderfrom fastapi.encoders import jsonable_encoderdef orm_to_pydantic(orm_model): \"\"\"將 ORM model 的資料搬移到 Pydantic model\"\"\" # 1. convert orm model to json format by jsonable_encoder # 2. unwrapped jsonable query_result into UserSchema(as user pydantic model) jsonable_result = jsonable_encoder(orm_model) return UserSchema(**jsonable_result)def pydantic_to_orm(pydantic_model): \"\"\"將 Pydantic model 的資料搬移到 ORM model\"\"\" return User(**pydantic_model.dict())def query_user(): # get database session, it will return generator first db = get_db_session() # execute database query, the result is a list of user orm model users_orm_model = db.query(User).all() user_pydantic_model = [orm_to_pydantic(user_orm_model) for user_orm_model in users_orm_model] print(user_pydantic_model) 上面程式碼，有兩個關於 database operation的部分還沒提到，分別是 database session instance 建立以及 datbase CRUD operation，這兩個部分後面章節會介紹，暫時先不再這裡解釋 jsonable_encoder 是 FastAPI 提供的一個方便進行資料格式轉化工具，可以將資料轉換成 JSON data format詳細可以參考至FastAPI - JSON Compatible Encoder Pydantic model Config延續 如何進行 Pydantic model 和 ORM model 資料搬移? 章節，當執行範例程式碼會發現回傳出來的結果 pydanic model 的 attribute books 裡面的資料是空的，但如果直接看 database query 的結果反而可以看到關聯資料，為什麼會發生這類情況呢? 主要原因在於 ORM 本身 lazy loading 特性的關係 ORM lazy loading，會讓有建立關聯的 orm model，不能直接抽取關聯資料，除非直接去 access 該 orm model 代表關聯的 attribute e.g 以上述宣告的 Users model 為例，並且以 my_user 代表該 orm model 的 instance，如果要取得關聯的 book 資料，就必須要 access attribute my_user.books 這樣 database 才可以根據 foreign key 找到關聯資料並抽取出來 關於這部分問題的解決方式，可以透過 Pydantic model Config 設定 orm_mode 來處理 orm_mode 可以讓 Pydantic model compatible with ORM model，讀取 ORM model資料，一方面進行資料搬移的時候不會出現找不到關聯資料的問題，另一方面因為 pydantic model 整合 FastAPI，可以直接將 Pydantic model 宣告在 path response，當對 db讀取資料，可以不用再手動進行 ORM to Pydantic model的資料搬移，直接在 path operation function 內回傳 orm model就行 宣告方式，只需要在該 pydantic model 內設定以下程式碼即可 For example123456789class User(BaseModel): id: int = Field(...) name: str = Field(...) email: str = Field(...) active: bool = Field(...) books: List[Books] # 加在這裡 class Config: orm_mode = True Pydantic model 加入 orm_mode 之後，可以在回 如何進行 Pydantic model 和 ORM model 資料搬移? 章節，實際測試範例程式碼，並確認輸出結果，是不是有解決問題 設定好 orm_mode之後，還有哪些地方，可以感受到差異呢? 在 path operation 宣告 response_model 透過 orm_mode，可以直接在 path opearation 直接回傳目標資料的 orm model，fastapi 會再根據 response_model 進行資料驗證及資料轉化 1234567# assume get_db_session declare in database.pyfrom .database import get_db_sessionfrom .schemas import UserSchemafrom .models import User@app.get('/user', response_model=List[UserSchema])def get_all_user(db = get_db_session()): return db.query(User).all() 建立資料庫 CRUD 方法在 FastAPI 內建立 crud 方法，建議根據不同 ORM model(也可以視為不同 table) 來建立各自獨立的 DB操作模組，可以提供給 path operation 使用之外，也方便進行 unit testing 以下程式碼將會實現基本 CRUD method，並描述在 crud.py 123456789101112131415161718192021222324# import database session 定義 function parameter 的型別from sqlalchemy.orm import Sessionfrom .models import Userfrom .schemas import User as UserSchema# 指定查詢符合 User.id 的 user table 資料def get_user(db: Session, user_id: int): return db.query(User).filter(User.id === user_id)# 查詢所有 user 資料，並限制每次查詢數量def get_users(db: Session, skip: int = 0, limit: int = 100): return db.query(models.User).offset(skip).limit(limit).all() # 建立 user table 資料def craete(db: Session, user_in: UserSchema): # 轉化 pydantic model to orm model created_user = User(**user_in.dict()) # add instance object into database session # 增加 user orm model 所建立的 instance 到 database session db.add(created_user) # 提交 transaction to database (該 instance 會確實保存在 database) db.commit() # refresh instance (從 database 抽取該 instance 資料) db.refresh(created_user) 可以參考各大網站提供的 SQLAlchemy crud method，這邊就不特別引用參考了關於 Database session 進行基礎 CRUD操作的細節介紹，也可以參考 SQLAlchemy - Basics of Using a Session 實際使用 database operation到目前為止，已經宣告好 database crud 操作了，接著該如何實際使用? FastAPI 透過 SQLAlchemy ORM 操作 database，實際上是透過 database session，還記得在 initial create SQLAlchemy 這個章節，有 create database session，接下來如果需要進行任何有關 database 操作，首先需要先建立 database session instance，如下 關於 Session 這部分操作的細節介紹，也可以參考 SQLAlchemy - When do I construct a Session, when do I commit it, and when do I close it? 這邊預期開發者已建立好 database及對應的 table schema如果開發者尚未建立 database 及 table schema，以下程式碼將會無法使用建議開發者們可以自行手動建立 database and table schema 或是使用 database migration如果不清楚 database migration，可以參考 Database migration 以下為範例程式碼，建議可以建立一個測試腳本 test.py 來實際運作試試 1234567891011121314151617from .database import get_db_sessionfrom .crud import get_userfrom .schema import User as UserSchema# import fastapi 提供的 json 資料格式轉化工具，協助 transfer data from orm model to pydantic modelfrom fastapi.encoders import jsonable_encoderif __name__ == \"__main__\": # 取得 database session instance，這邊， db_session = next(get_db_session()) # 執行 database query，並回傳 User model user = get_user(db_session, user_id=1) # 針對 orm model 指定欄位資料的方式，需要像 class.attribute 這樣，以 class 指定 attribute 的方式來 access value print(user.id) # 將 user orm model 的資料搬移給 user 的 pydantic model，進行資料驗證和轉化 user = UserSchema(**jsonable_encoder(user)) # pydantic model 可以直接轉化成 dict print(user.dict()) next() 可以取得 iterable object中的下一個 object，generator 也是屬於 iterable object 在 path operation 使用 database operation經過上一個章節實際使用 database operation 的介紹，已經知道如何單獨使用 database crud method 接下來這一個章節，將會介紹該如何在 FastAPI path operation 中進行 database crud operation 在檔案結構章節有提到main.py 這個 fastapi 執行檔，以下程式碼將會描述在該檔案 123456789101112131415161718from .database import get_db_sessionfrom .crud import get_userfrom .schema import User as UserSchema# import fastapi 提供的 json 資料格式轉化工具，協助 transfer data from orm model to pydantic modelfrom fastapi.encoders import jsonable_encoderfrom fastapi import Depend, FastAPI, HTTPExceptionapp = FastAPI()@app.get('/user/{user_id}', response_model=UserSchema)def get_user(user_id: int, db_session: Session = Depends(get_db_session)): # 執行 database query，並回傳 User model user = get_user(db_session, user_id=user_id) # 針對 orm model 指定欄位資料的方式，需要像 class.attribute 這樣，以 class 指定 attribute 的方式來 access value print(user.id) # 將 user orm model 的資料搬移給 user 的 pydantic model，進行資料驗證和轉化 user = UserSchema(**jsonable_encoder(user)) # pydantic model 可以直接轉化成 dict print(user.dict()) return 解釋Depends(get_db_session) 已知如果要進行 database operation，需要透過 get_db_session() 取得 database session instance 不過針對 API 每一次 request，都需要建立一個新的 session 來處理 request，該怎麼做呢? 每個 path operation 都宣告 db = next(get_db_session()) 來取得 session instance 透過 FastAPI 支援的 Dependency 功能，在 request 近來 fucntion 之前，先取得 session instance 之後，在 inject 到 path operation function，並在 API respond 之後，關閉 session 連線 Reference以上內容均參考至 FastAPI - SQL (Relational) Databases FastAPI - JSON Compatible Encoder FastAPI- Database migration SQLAlchemy 進階用法待補充","link":"/2021/01/20/fastapi-ch5/"}],"tags":[{"name":"FastAPI","slug":"FastAPI","link":"/tags/FastAPI/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Framework","slug":"Framework","link":"/tags/Framework/"},{"name":"FastAPI, Python, Framework","slug":"FastAPI-Python-Framework","link":"/tags/FastAPI-Python-Framework/"}],"categories":[{"name":"Python","slug":"Python","link":"/categories/Python/"}]}