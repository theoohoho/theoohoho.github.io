<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on</title><link>https://theoohoho.github.io/categories/python/</link><description>Recent content in Python on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 08 Mar 2023 15:48:04 +0000</lastBuildDate><atom:link href="https://theoohoho.github.io/categories/python/index.xml" rel="self" type="application/rss+xml"/><item><title>FastAPI 常見問題 - SQLalchemy session</title><link>https://theoohoho.github.io/blog/fastapi-%E5%B8%B8%E8%A6%8B%E5%95%8F%E9%A1%8C-sqlalchemy-session/</link><pubDate>Wed, 08 Mar 2023 15:48:04 +0000</pubDate><guid>https://theoohoho.github.io/blog/fastapi-%E5%B8%B8%E8%A6%8B%E5%95%8F%E9%A1%8C-sqlalchemy-session/</guid><description>最近在壓測系統時，有觀察到 database connection 異常暴漲的問題，原本用 singleton pattern 封裝 database class 解決問題，確保單台 application server 只會有單個 db instance，限制 db connection 不超過 connection pool 的上限，但後續遇到這個錯誤:
調查之後發現，是 FastAPI 專案使用到 sqlalchemy scoped_session 的方式，封裝 session factory，導致錯誤產生。
所以本文將會簡單說明 FastAPI and sqlalchemy 整合的常見問題，會再帶一點 sqlalchemy scoped_session 的介紹
期許讀完這篇文之後，可以了解彼此方法的差異
正文開始 # 一般而言，使用 FastAPI 宣告 database session 的方式有兩種
official: 官方建議，透過 FastAPI 支援的 dependency injection 方式，定義產生 session 的 generator，並 depends 給所有 path operation (aka api endpoint) 使用 middleware: 在 middleware 定義 session create and session close，session 會跟著 request 傳入 path operation (aka api endpoint) 使用 這兩種方式的想要達成的效果相同，都是想讓 db session 的使用週期可以綁定 request 一起開始和結束，簡單來說就是 request 近來會先建立 db session，當 server 產生 response 之後，可以結束 db session</description></item></channel></rss>